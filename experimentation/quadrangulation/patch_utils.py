
import constants
import numpy as np
from scipy.optimize import linprog

# Debug 
import matplotlib.pyplot as plt


def generate_edge_vertices(first_vertex: np.array, 
                           last_vertex: np.array,
                           section_segments=[1]):
    """
    Generates an array of vertices according to the number of section.
    The edge can be divided into sections, each with a different number
    of segments. One segment connects two vertices.
    
    Example:
    
    [0]---------+-----+---[20]
           9    |  5  | 3 -> section_sizes=[9, 5, 3]
              [10]   [16]

    ----------
    first_vertex : np.array
        2D vertex where the edge starts. It will also start with the first section
    last_vertex : np.array
        2D vertex where the edge starts. It will also start with the first section
    section_sizes : list, optional
        List of sizes the will determine how edge vertex will be divided
    """
    total_num_segments = np.sum(section_segments)
    total_num_vertices = total_num_segments + 1
    
    # Calculate vertices
    vertices = np.ndarray((total_num_vertices, 2), dtype=np.float32)
    vertices[:, 0] = np.linspace(start=first_vertex[0], 
                                 stop=first_vertex[1], 
                                 num=total_num_vertices, 
                                 endpoint=True)
    vertices[:, 1] = np.linspace(start=last_vertex[0], 
                                 stop=last_vertex[1], 
                                 num=total_num_vertices, 
                                 endpoint=True)
    
    # TODO: COntinue form here
    # Calculate indices
    counter = 0
    notch_indices = []
    for segments in section_segments:
        notch_indices.append()
    g = 0
    
    pass

# =======================================================
#                   AI Generated
# =======================================================


def generate_grid_mesh(c0, c1, c2, c3, rows, cols):
    # [ Code Generated by Bing AI ]
    
    # Calculate the vectors along the sides
    v1 = (c1 - c0) / cols
    v2 = (c3 - c0) / rows
    v3 = (c2 - c3) / cols
    v4 = (c2 - c1) / rows
    
    # Generate vertex coordinates
    vertices = np.array([c0 + i * v1 + j * v2 + i * j * (v3 + v4 - v1 - v2) / (rows * cols) for j in range(rows + 1) for i in range(cols + 1)])
    
    # Generate edge indices
    horizontal_edges = [[i + j * (cols + 1), i + j * (cols + 1) + 1] for j in range(rows + 1) for i in range(cols)]
    vertical_edges = [[i + j * (cols+1), i+(j+1)*(cols+1)] for j in range(rows) for i in range(cols+1)]
    edges = np.array(horizontal_edges+vertical_edges)
    
    # Generate face indices
    faces = np.array([[i+j*(cols+1),i+j*(cols+1)+1,i+(j+1)*(cols+1)+cols+2,i+(j+1)*(cols+1)+cols+1] for j in range(rows) for i in range(cols)])
    
    return vertices, edges, faces

def plot_grid_mesh(vertices, edges):
    # [ Code Generated by Bing AI]
    
    # Plot vertices
    plt.scatter(vertices[:,0], vertices[:,1])
    
    # Plot edges
    for edge in edges:
        x_coords = [vertices[edge[0]][0], vertices[edge[1]][0]]
        y_coords = [vertices[edge[0]][1], vertices[edge[1]][1]]
        plt.plot(x_coords, y_coords)
    
    # Show plot
    plt.show()
    
def stitch_quadrilateral_meshes(quads):
    # [ Code Generated by Bing AI and tweaked by me]
    
    # quads: List of tuples (c0,c1,c2,c3,row,col)
    
    # Initialize global lists
    g_vertices = []
    g_edges = []
    g_faces = []
    
    # Initialize vertex hash table
    v_hash = {}
    
    for quad in quads:
        
        c0,c1,c2,c3,row,col = quad
        
        # Generate local mesh
        l_vertices,l_edges,l_faces = generate_grid_mesh(c0,c1,c2,c3,row,col)
        
        # Mapping from local vertex index to global vertex index
        global_vertex_indices = {}
        
        # Add unique vertices to global vertex list
        for i,v in enumerate(l_vertices):
            v_key = tuple(v)
            if v_key not in v_hash:
                global_vertex_indices[i] = len(g_vertices)
                g_vertices.append(v)
                v_hash[v_key] = global_vertex_indices[i]
            else:
                global_vertex_indices[i] = v_hash[v_key]
                
        # Update local edge indices with global vertex indices
        l_edges = [[global_vertex_indices[e[0]],global_vertex_indices[e[1]]] for e in l_edges]
        
        # Add unique edges to global edge list
        for e in l_edges:
            if e not in g_edges:
                g_edges.append(e)
                
        # Update local face indices with global vertex indices
        l_faces = [[global_vertex_indices[f[0]],
                    global_vertex_indices[f[1]],
                    global_vertex_indices[f[2]],
                    global_vertex_indices[f[3]]] for f in l_faces]
        
        # Add faces to global face list
        g_faces.extend(l_faces)
    
    return np.array(g_vertices),np.array(g_edges),np.array(g_faces)

def stitch_and_plot_quads(quad1, quad2, quad3):
    # Stitch quadrilaterals together
    vertices, edges, faces = stitch_quadrilateral_meshes([quad1, quad2, quad3])
    
    # Plot mesh
    plot_grid_mesh(vertices, edges)

if __name__ == "__main__":
    
    # Setup
    first_vertex = np.array((0, 0))
    last_vertex = np.array((1, 1))
    section_segments = [1, 2]
    
    # Main
    results = generate_edge_vertices(first_vertex=first_vertex,
                                     last_vertex=last_vertex,
                                     section_segments=section_segments)
    expected_output = np.array([[0., 0.], [0.5, 0.5], [1., 1.]])
    
    self.assertTrue(np.allclose(interpolate_2d(start, end, num_points), expected_output))